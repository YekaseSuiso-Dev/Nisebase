import { relative, resolve, dirname, join, sep, basename } from 'node:path';
import { sep as sep$1 } from 'node:path/posix';
import { fileURLToPath } from 'node:url';
import fs from 'fs-extra';
import { glob } from 'glob';
import { green, red, cyan, gray, yellow } from 'colorette';
import GrayMatter from 'gray-matter';
import { unified } from 'unified';
import RehypeMeta from 'rehype-meta';
import RehypeParse from 'rehype-parse';
import RehypeStringify from 'rehype-stringify';
import ora from 'ora';
import { Resvg } from '@resvg/resvg-js';
import regexCreator from 'emoji-regex';

function getLocales(siteData) {
  const locales = [];
  locales.push(siteData.lang ?? "root");
  if (Object.keys(siteData.locales).length === 0)
    return locales;
  for (const locale in siteData.locales) {
    if (locale !== siteData.lang)
      locales.push(locale);
  }
  return locales;
}
function getTitleWithLocales(siteData, locale) {
  if (Object.keys(siteData.locales).length > 0) {
    const title = siteData.locales[locale]?.title;
    if (title)
      return title;
    if (siteData.locales.root.title)
      return siteData.locales.root.title;
    return siteData.title;
  }
  return siteData.title;
}
function getDescriptionWithLocales(siteData, locale) {
  if (Object.keys(siteData.locales).length > 0) {
    const description = siteData.locales[locale]?.description;
    if (description)
      return description;
    if (siteData.locales.root.description)
      return siteData.locales.root.description;
    return siteData.description;
  }
  return siteData.description;
}

function getSidebar(siteData, themeConfig) {
  const locales = getLocales(siteData);
  if (locales.length === 0) {
    return {
      defaultLocale: siteData.lang,
      locales: locales || [],
      sidebar: {
        [siteData.lang]: flattenThemeConfigSidebar(themeConfig.sidebar) || []
      }
    };
  }
  const sidebar = {
    defaultLocale: siteData.lang,
    locales,
    sidebar: {}
  };
  for (const locale of locales) {
    let themeConfigSidebar = [];
    if (typeof siteData.locales[locale]?.themeConfig?.sidebar !== "undefined")
      themeConfigSidebar = siteData.locales[locale]?.themeConfig?.sidebar || [];
    else if (typeof siteData.themeConfig?.sidebar !== "undefined")
      themeConfigSidebar = siteData.themeConfig?.sidebar || [];
    else if (typeof themeConfig.sidebar !== "undefined")
      themeConfigSidebar = themeConfig.sidebar;
    else
      themeConfigSidebar = [];
    sidebar.sidebar[locale] = flattenThemeConfigSidebar(themeConfigSidebar) || [];
  }
  return sidebar;
}
function flattenThemeConfigSidebar(sidebar) {
  if (!sidebar)
    return [];
  if (Array.isArray(sidebar))
    return sidebar;
  return Object.keys(sidebar).reduce((prev, curr) => {
    const items = sidebar[curr];
    return prev.concat(items);
  }, []);
}
function flattenSidebar(sidebar) {
  return sidebar.reduce((prev, curr) => {
    if (curr.items)
      return prev.concat(flattenSidebar(curr.items));
    return prev.concat(curr);
  }, []);
}

const okMark = green("\u2713");
const failMark = red("\u2716");
async function task(taskName, task2) {
  const startsAt = Date.now();
  const moduleNamePrefix = cyan("@nolebase/vitepress-plugin-og-image");
  const grayPrefix = gray(":");
  const spinnerPrefix = `${moduleNamePrefix}${grayPrefix}`;
  const spinner = ora({ discardStdin: false });
  spinner.start(`${spinnerPrefix} ${taskName}...`);
  let result;
  try {
    result = await task2();
  } catch (e) {
    spinner.stopAndPersist({ symbol: failMark });
    throw e;
  }
  const elapsed = Date.now() - startsAt;
  const suffixText = `${gray(`(${elapsed}ms)`)} ${result}` ?? "";
  spinner.stopAndPersist({ symbol: okMark, suffixText });
}
function renderTaskResultsSummary(results, siteConfig) {
  const successCount = results.filter((item) => item.status === "success");
  const skippedCount = results.filter((item) => item.status === "skipped");
  const erroredCount = results.filter((item) => item.status === "errored");
  const stats = `${green(`${successCount.length} generated`)}, ${yellow(`${skippedCount.length} skipped`)}, ${red(`${erroredCount.length} errored`)}`;
  const skippedList = ` - ${yellow("Following files were skipped")}:

${skippedCount.map((item) => {
    return gray(`    - ${relative(siteConfig.root, item.filePath)}: ${item.reason}`);
  }).join("\n")}`;
  const erroredList = ` - ${red("Following files encountered errors")}

${erroredCount.map((item) => {
    return gray(`    - ${relative(siteConfig.root, item.filePath)}: ${item.reason}`);
  }).join("\n")}`;
  const overallResults = [stats];
  if (skippedCount.length > 0)
    overallResults.push(skippedList);
  if (erroredCount.length > 0)
    overallResults.push(erroredList);
  return overallResults.join("\n\n");
}

const emojiRegex = regexCreator();
function removeEmoji(str) {
  return str.replace(emojiRegex, "");
}

const escapeMap = {
  "<": "&lt;",
  ">": "&gt;",
  "'": "&apos;",
  '"': "&quot;",
  "&": "&amp;"
};
function escape(content, ignore) {
  ignore = (ignore || "").replace(/[^&"<>\']/g, "");
  const pattern = `([&"<>'])`.replace(new RegExp(`[${ignore}]`, "g"), "");
  return content.replace(new RegExp(pattern, "g"), (_, item) => {
    return escapeMap[item];
  });
}

function templateSVG(siteName, siteDescription, title, category, ogTemplate) {
  const lines = removeEmoji(title).trim().replace(/(?![^\n]{1,17}$)([^\n]{1,17})\s/g, "$1\n").split("\n");
  lines.forEach((val, i) => {
    if (val.length > 17) {
      lines[i] = val.slice(0, 17);
      lines[i + 1] = `${val.slice(17)}${lines[i + 1] || ""}`;
    }
    lines[i] = lines[i].trim();
  });
  const categoryStr = category ? removeEmoji(category).trim() : "";
  const data = {
    siteName,
    siteDescription,
    category: categoryStr,
    line1: lines[0] || "",
    line2: lines[1] || "",
    line3: `${lines[2] || ""}${lines[3] ? "..." : ""}`
  };
  return ogTemplate.replace(/\{\{([^}]+)}}/g, (_, name) => {
    if (!name || typeof name !== "string" || !(name in data))
      return "";
    const nameKeyOf = name;
    return escape(data[nameKeyOf]);
  });
}
async function renderSVG(svgContent, options) {
  let resvg;
  try {
    resvg = new Resvg(svgContent, {
      fitTo: { mode: "width", value: 1200 },
      font: {
        fontFiles: options?.fontPath ? [options.fontPath] : [],
        // Load system fonts might cost more time
        loadSystemFonts: false
      }
    });
  } catch (err) {
    throw new Error(`Failed to initiate Resvg instance to render open graph images due to ${err}`);
  }
  try {
    return resvg.render().asPng();
  } catch (err) {
    throw new Error(`Failed to render open graph images on path due to ${err}`);
  }
}

const logModulePrefix = `${cyan(`@nolebase/vitepress-plugin-og-image`)}${gray(":")}`;
async function tryToLocateTemplateSVGFile(siteConfig) {
  const templateSvgPathUnderPublicDir = resolve(siteConfig.root, "public", "og-template.svg");
  if (await fs.pathExists(templateSvgPathUnderPublicDir))
    return templateSvgPathUnderPublicDir;
  const __dirname = dirname(fileURLToPath(import.meta.url));
  const templateSvgPathUnderRootDir = resolve(__dirname, "assets", "og-template.svg");
  if (await fs.pathExists(templateSvgPathUnderRootDir))
    return templateSvgPathUnderRootDir;
  return void 0;
}
async function tryToLocateFontFile(siteConfig) {
  const fontPathUnderPublicDir = resolve(siteConfig.root, "public", "SourceHanSansSC.otf");
  if (await fs.pathExists(fontPathUnderPublicDir))
    return fontPathUnderPublicDir;
  const __dirname = dirname(fileURLToPath(import.meta.url));
  const fontPathUnderRootDir = resolve(__dirname, "assets", "SourceHanSansSC.otf");
  if (await fs.pathExists(fontPathUnderRootDir))
    return fontPathUnderRootDir;
  return void 0;
}
async function renderSVGAndRewriteHTML(siteConfig, siteTitle, siteDescription, page, file, ogImageTemplateSvg, ogImageTemplateSvgPath, domain) {
  const fileName = basename(file, ".html");
  const ogImageFilePathBaseName = `og-${fileName}.png`;
  const ogImageFilePathFullName = `${dirname(file)}/${ogImageFilePathBaseName}`;
  const templatedOgImageSvg = templateSVG(
    siteTitle,
    siteDescription,
    page.title,
    page.category ?? "",
    ogImageTemplateSvg
  );
  try {
    await renderSVGAndSavePNG(
      templatedOgImageSvg,
      ogImageFilePathFullName,
      ogImageTemplateSvgPath,
      relative(siteConfig.root, file),
      { fontPath: await tryToLocateFontFile(siteConfig) }
    );
  } catch (err) {
    return {
      filePath: file,
      status: "errored",
      reason: String(err)
    };
  }
  const html = await fs.readFile(file, "utf-8");
  const result = await unified().use(RehypeParse).use(RehypeMeta, {
    og: true,
    twitter: true,
    name: siteTitle,
    description: siteDescription,
    image: {
      url: `${domain}/${encodeURIComponent(relative(siteConfig.outDir, ogImageFilePathFullName))}`
    }
  }).use(RehypeStringify).process(html);
  try {
    await fs.writeFile(file, String(result), "utf-8");
  } catch (err) {
    console.error(
      `${logModulePrefix} `,
      `${red("[ERROR] \u2717")} failed to write transformed HTML on path [${relative(siteConfig.root, file)}] due to ${err}`,
      `
${red(err.message)}
${gray(String(err.stack))}`
    );
    return {
      filePath: file,
      status: "errored",
      reason: String(err)
    };
  }
  return {
    filePath: file,
    status: "success"
  };
}
async function renderSVGAndSavePNG(svgContent, saveAs, forSvgSource, forFile, options) {
  let pngBuffer;
  try {
    pngBuffer = await renderSVG(svgContent, { fontPath: options.fontPath });
  } catch (err) {
    console.error(
      `${logModulePrefix} `,
      `${red("[ERROR] \u2717")} failed to generate open graph image as ${green(`[${saveAs}]`)} with ${green(`[${forSvgSource}]`)} due to ${red(String(err))}`,
      `skipped open graph image generation for ${green(`[${forFile}]`)}`,
      `

SVG Content:

${svgContent}`,
      `

Detailed stack information bellow:

${red(err.message)}
${gray(String(err.stack))}`
    );
    throw err;
  }
  try {
    await fs.writeFile(saveAs, pngBuffer, "binary");
  } catch (err) {
    console.error(
      `${logModulePrefix} `,
      `${red("[ERROR] \u2717")} open graph image rendered successfully, but failed to write generated open graph image on path [${saveAs}] due to ${err}`,
      `
${red(err.message)}
${gray(String(err.stack))}`
    );
    throw err;
  }
}
async function applyCategoryText(pageItem, categoryOptions) {
  if (typeof categoryOptions?.byCustomGetter !== "undefined") {
    const gotTextMaybePromise = categoryOptions.byCustomGetter({ ...pageItem });
    if (typeof gotTextMaybePromise === "undefined")
      return void 0;
    if (gotTextMaybePromise instanceof Promise)
      return await gotTextMaybePromise;
    if (gotTextMaybePromise)
      return gotTextMaybePromise;
    return void 0;
  }
  if (typeof categoryOptions?.byPathPrefix !== "undefined") {
    for (const { prefix, text } of categoryOptions.byPathPrefix) {
      if (pageItem.normalizedSourceFilePath.startsWith(prefix)) {
        if (!text) {
          console.warn(
            `${logModulePrefix} ${yellow("[WARN]")} empty text for prefix ${prefix} when processing ${pageItem.sourceFilePath} with categoryOptions.byPathPrefix, will ignore...`
          );
          return void 0;
        }
        return text;
      }
      if (pageItem.normalizedSourceFilePath.startsWith(`/${prefix}`)) {
        if (!text) {
          console.warn(
            `${logModulePrefix} ${yellow("[WARN]")} empty text for prefix ${prefix} when processing ${pageItem.sourceFilePath} with categoryOptions.byPathPrefix, will ignore...`
          );
          return void 0;
        }
        return text;
      }
    }
    console.warn(
      `${logModulePrefix} ${yellow("[WARN]")} no path prefix matched for ${pageItem.sourceFilePath} with categoryOptions.byPathPrefix, will ignore...`
    );
    return void 0;
  }
  if (typeof categoryOptions?.byLevel !== "undefined") {
    const level = Number.parseInt(String(categoryOptions?.byLevel ?? 0));
    if (Number.isNaN(level)) {
      console.warn(
        `${logModulePrefix} ${yellow("[ERROR]")} byLevel must be a number, but got ${categoryOptions.byLevel} instead when processing ${pageItem.sourceFilePath} with categoryOptions.byLevel, will ignore...`
      );
      return void 0;
    }
    const dirs = pageItem.sourceFilePath.split(sep);
    if (dirs.length > level)
      return dirs[level];
    console.warn(`${logModulePrefix} ${red(`[ERROR] byLevel is out of range for ${pageItem.sourceFilePath} with categoryOptions.byLevel.`)} will ignore...`);
    return void 0;
  }
  return void 0;
}
async function applyCategoryTextWithFallback(pageItem, categoryOptions) {
  const customText = await applyCategoryText(pageItem, categoryOptions);
  if (customText)
    return customText;
  const fallbackWithFrontmatter = typeof categoryOptions?.fallbackWithFrontmatter === "undefined" ? true : categoryOptions.fallbackWithFrontmatter;
  if (fallbackWithFrontmatter && "category" in pageItem.frontmatter && pageItem.frontmatter.category && typeof pageItem.frontmatter.category === "string")
    return pageItem.frontmatter.category ?? "";
  console.warn(`${logModulePrefix} ${yellow("[WARN]")} no category text found for ${pageItem.sourceFilePath} with categoryOptions ${JSON.stringify(categoryOptions)}.}`);
  return "Un-categorized";
}
function buildEndGenerateOpenGraphImages(options) {
  return async (siteConfig) => {
    const ogImageTemplateSvgPath = await tryToLocateTemplateSVGFile(siteConfig);
    await task("rendering open graph images", async () => {
      const themeConfig = siteConfig.site.themeConfig;
      const sidebar = getSidebar(siteConfig.site, themeConfig);
      let pages = [];
      for (const locale of sidebar.locales) {
        const flattenedSidebar = flattenSidebar(sidebar.sidebar[locale]);
        const items = [];
        for (const item of flattenedSidebar) {
          const relativeLink = item.link ?? "";
          const sourceFilePath = relativeLink.endsWith("/") ? `${relativeLink}index.md` : `${relativeLink}.md`;
          const sourceFileContent = fs.readFileSync(`${join(siteConfig.root, sourceFilePath)}`, "utf-8");
          const { data } = GrayMatter(sourceFileContent);
          const res = {
            ...item,
            title: item.text ?? item.title ?? "Untitled",
            category: "",
            locale,
            frontmatter: data,
            sourceFilePath,
            normalizedSourceFilePath: sourceFilePath.split(sep).join(sep$1)
          };
          res.category = await applyCategoryTextWithFallback(res, options.category);
          items.push(res);
        }
        pages = pages.concat(items);
      }
      const files = await glob(`${siteConfig.outDir}/**/*.html`, { nodir: true });
      if (!ogImageTemplateSvgPath) {
        return `${green(`${0} generated`)}, ${yellow(`${files.length} (all) skipped`)}, ${red(`${0} errored`)}.

 - ${red("Failed to locate")} og-template.svg ${red("under public or plugin directory")}, did you forget to put it? will skip open graph image generation.`;
      }
      const ogImageTemplateSvg = fs.readFileSync(ogImageTemplateSvgPath, "utf-8");
      const generatedForFiles = await Promise.all(files.map(async (file) => {
        const relativePath = relative(siteConfig.outDir, file);
        const link = `/${relativePath.slice(0, relativePath.lastIndexOf(".")).replaceAll(sep, "/")}`.split("/index")[0];
        const page = pages.find((item) => {
          if (item.link === link)
            return true;
          if (item.link === `${link}/`)
            return true;
          return false;
        });
        if (!page) {
          return {
            filePath: file,
            status: "skipped",
            reason: "correspond Markdown page not found in sidebar"
          };
        }
        const siteTitle = getTitleWithLocales(siteConfig.site, page.locale);
        const siteDescription = getDescriptionWithLocales(siteConfig.site, page.locale);
        return await renderSVGAndRewriteHTML(
          siteConfig,
          siteTitle,
          siteDescription,
          page,
          file,
          ogImageTemplateSvg,
          ogImageTemplateSvgPath,
          options.baseUrl
        );
      }));
      return renderTaskResultsSummary(generatedForFiles, siteConfig);
    });
  };
}

export { buildEndGenerateOpenGraphImages };
//# sourceMappingURL=index.mjs.map
