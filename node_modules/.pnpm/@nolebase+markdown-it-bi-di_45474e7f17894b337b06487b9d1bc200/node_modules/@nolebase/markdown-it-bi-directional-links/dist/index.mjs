import { sep, relative, basename, extname, posix } from 'node:path';
import { env } from 'node:process';
import { globSync } from 'glob';
import { cyan, gray, yellow } from 'colorette';

function findBiDirectionalLinks(possibleBiDirectionalLinksInFilePaths, possibleBiDirectionalLinksInFullFilePaths, href) {
  if (!href)
    return null;
  if (href.includes(sep))
    return possibleBiDirectionalLinksInFullFilePaths[href];
  return possibleBiDirectionalLinksInFilePaths[href];
}
function genLink(state, resolvedNewHref, text, md, href, link) {
  const openToken = state.push("link_open", "a", 1);
  openToken.attrSet("href", resolvedNewHref);
  const linkTokenChildrenContent = [];
  const parsedUrl = new URL(href, "https://a.com");
  const hrefWithoutSearchAndHash = decodeURIComponent(parsedUrl.pathname.slice(1));
  const parsedInlineTokens = text ? md.parseInline(text, state.env) : md.parseInline(hrefWithoutSearchAndHash, state.env) || [];
  if (parsedInlineTokens && parsedInlineTokens.length) {
    parsedInlineTokens.forEach((tokens) => {
      if (!tokens.children)
        return;
      tokens.children.forEach((token) => {
        linkTokenChildrenContent.push(token);
      });
    });
  }
  for (const token of linkTokenChildrenContent) {
    const pushedToken = state.push(token.type, token.tag, token.nesting);
    pushedToken.content = token.content;
  }
  state.push("link_close", "a", -1);
  state.pos += link[0].length;
}
function genImage(state, resolvedNewHref, text, link) {
  const openToken = state.push("image", "img", 1);
  openToken.attrSet("src", resolvedNewHref);
  openToken.attrSet("alt", "");
  openToken.children = [];
  openToken.content = text;
  const innerTextToken = state.push("text", "", 0);
  innerTextToken.content = text;
  openToken.children.push(innerTextToken);
  state.pos += link[0].length;
}

const biDirectionalLinkPattern = /\!?\[\[([^|\]\n]+)(\|([^\]\n]+))?\]\](?!\()/;
const biDirectionalLinkPatternWithStart = /^\!?\[\[([^|\]\n]+)(\|([^\]\n]+))?\]\](?!\()/;
const IMAGES_EXTENSIONS = [
  ".png",
  ".jpg",
  ".jpeg",
  ".gif",
  ".svg",
  ".webp",
  ".ico",
  ".bmp",
  ".tiff",
  ".apng",
  ".avif",
  ".jfif",
  ".pjpeg",
  ".pjp",
  ".png",
  ".svg",
  ".webp",
  ".xbm"
];
const logModulePrefix = `${cyan(`@nolebase/markdown-it-bi-directional-links`)}${gray(":")}`;
function logIncorrectMatchedMarkupWarning(input, src, path) {
  const debug = env?.DEBUG ?? "";
  if (!debug)
    return;
  let shouldLog = false;
  if (debug === "@nolebase/*")
    shouldLog = true;
  if (debug === "@nolebase/markdown-it-*")
    shouldLog = true;
  if (debug === "@nolebase/markdown-it-bi-directional-links")
    shouldLog = true;
  if (!shouldLog)
    return;
  console.warn(`${logModulePrefix} ${yellow("[WARN]")} Matched markup '${input}' is not at the start of the text. ${yellow(`

Things to check:

  1. Is this a expected markup for bi-directional links?
  2. Is there any other markup before this markup?`)}

${yellow("Source text:")}

  ${gray(src)}

  ${gray(`at`)} ${cyan(path)}
`);
}
function logNoMatchedFileWarning(rootDir, inputContent, markupTextContent, href, osSpecificHref, path, relevantPath) {
  console.warn(`${logModulePrefix} ${yellow("[WARN]")} No matched file found for '${osSpecificHref}' based on ${rootDir}, ignored. ${yellow(`

Things to check:

  1. Was the matched most relevant file expected?
    1. Was it renamed during the build process?
    2. Does it exist in the file system with the correct path?
    3. Does it have the correct extension? (Either .md for Markdown files or image extensions)
    4. Does it have the correct case? (Linux is Case-sensitive while macOS isn't)
    5. Does it have any special characters in the file name? (e.g. back slashes, quotes, illegal characters, etc.
  2. If <N/A> was shown, it means no relevant path was found. In such cases:
    1. Check the file system for the file if you expect it to get matched.
    2. Check whether mis-spelling or incorrect path was used in the markup.
  3. If you are using a custom base directory, check whether the base directory is correct.`)}

Matching chain:

  ${gray(inputContent)}
    -> ${gray(markupTextContent)}
      -> ${gray(href)}

${relevantPath ? `The most relevant paths: "${gray(relevantPath.key ?? "<N/A>")} matched by ${relevantPath.source ?? "<N/A>"}"` : ""}

  ${gray("at")} "${cyan(path)}"
`);
}
function findTheMostRelevantOne(possibleBiDirectionalLinksInCleanBaseNameOfFilePaths, possibleBiDirectionalLinksInFullFilePaths, href) {
  for (const key in possibleBiDirectionalLinksInCleanBaseNameOfFilePaths) {
    if (key.includes(href)) {
      return {
        key: possibleBiDirectionalLinksInCleanBaseNameOfFilePaths[key],
        source: "file name"
      };
    }
  }
  for (const key in possibleBiDirectionalLinksInFullFilePaths) {
    if (key.includes(href)) {
      return {
        key: possibleBiDirectionalLinksInFullFilePaths[key],
        source: "absolute path"
      };
    }
  }
}
const BiDirectionalLinks = (options) => {
  const rootDir = options.dir;
  const includes = options?.includesPatterns ?? [];
  const possibleBiDirectionalLinksInCleanBaseNameOfFilePaths = {};
  const possibleBiDirectionalLinksInFullFilePaths = {};
  if (includes.length === 0) {
    includes.push("**/*.md");
    IMAGES_EXTENSIONS.forEach((ext) => includes.push(`**/*${ext}`));
  }
  for (const include of includes) {
    const files = globSync(include, {
      nodir: true,
      absolute: true,
      cwd: rootDir,
      ignore: [
        "_*",
        "dist",
        "node_modules"
      ]
    });
    for (const file of files) {
      const relativeFilePath = relative(rootDir, file);
      const partialFilePathWithOnlyBaseName = basename(relativeFilePath);
      const existingFileName = possibleBiDirectionalLinksInCleanBaseNameOfFilePaths[partialFilePathWithOnlyBaseName];
      if (typeof existingFileName === "string" && existingFileName !== "") {
        delete possibleBiDirectionalLinksInCleanBaseNameOfFilePaths[partialFilePathWithOnlyBaseName];
        delete possibleBiDirectionalLinksInFullFilePaths[existingFileName];
        possibleBiDirectionalLinksInFullFilePaths[relativeFilePath] = relativeFilePath;
        possibleBiDirectionalLinksInFullFilePaths[existingFileName] = existingFileName;
        continue;
      }
      possibleBiDirectionalLinksInCleanBaseNameOfFilePaths[partialFilePathWithOnlyBaseName] = relativeFilePath;
      possibleBiDirectionalLinksInFullFilePaths[relativeFilePath] = relativeFilePath;
    }
  }
  return (md) => {
    md.inline.ruler.after("text", "bi_directional_link_replace", (state) => {
      const src = state.src.slice(state.pos, state.posMax);
      const link = src.match(biDirectionalLinkPattern);
      if (!link)
        return false;
      if (!link.input)
        return false;
      if (!biDirectionalLinkPatternWithStart.exec(link.input)) {
        logIncorrectMatchedMarkupWarning(link.input, src, state.env.path);
        return false;
      }
      const isAttachmentRef = link.input.startsWith("!");
      const inputContent = link.input;
      const markupTextContent = link[0];
      const href = link[1];
      const text = link[3] ?? "";
      const isImageRef = isAttachmentRef && IMAGES_EXTENSIONS.some((ext) => href.endsWith(ext));
      const parsedHref = new URL(href, "https://a.com");
      const parsedPathname = decodeURIComponent(parsedHref.pathname.slice(1));
      let osSpecificHref = parsedPathname.split("/").join(sep);
      if (!isImageRef && (extname(osSpecificHref) === "" || extname(osSpecificHref) !== ".md"))
        osSpecificHref += ".md";
      const matchedHref = findBiDirectionalLinks(possibleBiDirectionalLinksInCleanBaseNameOfFilePaths, possibleBiDirectionalLinksInFullFilePaths, osSpecificHref);
      if (!matchedHref) {
        const relevantPath = findTheMostRelevantOne(possibleBiDirectionalLinksInCleanBaseNameOfFilePaths, possibleBiDirectionalLinksInFullFilePaths, osSpecificHref);
        logNoMatchedFileWarning(rootDir, inputContent, markupTextContent, href, osSpecificHref, state.env.path, relevantPath);
        return false;
      }
      let resolvedNewHref = posix.join(
        options.baseDir ?? "/",
        relative(rootDir, matchedHref).split(sep).join("/")
      );
      if (isImageRef) {
        genImage(state, resolvedNewHref, text, link);
      } else {
        resolvedNewHref = resolvedNewHref + parsedHref.search + parsedHref.hash;
        genLink(state, resolvedNewHref, text, md, href, link);
      }
      return true;
    });
  };
};

export { BiDirectionalLinks };
