import { cwd } from 'node:process';
import ora from 'ora';
import { cyan, gray } from 'colorette';
import { globby } from 'globby';
import { execa } from 'execa';
import { extname, relative, dirname, basename } from 'node:path';
import { subtle } from 'uncrypto';
import { normalizePath } from 'vite';
import GrayMatter from 'gray-matter';

function pathEquals(path, equals) {
  return normalizePath(path) === normalizePath(equals);
}
function pathStartsWith(path, startsWith) {
  return normalizePath(path).startsWith(normalizePath(startsWith));
}
function pathEndsWith(path, startsWith) {
  return normalizePath(path).endsWith(normalizePath(startsWith));
}
function createHelpers(root, id) {
  const relativeId = relative(root, id);
  return {
    pathStartsWith,
    pathEquals,
    pathEndsWith,
    idEndsWith(endsWith) {
      return pathEndsWith(relativeId, endsWith);
    },
    idEquals(equals) {
      return pathEquals(relativeId, equals);
    },
    idStartsWith(startsWith) {
      return pathStartsWith(relativeId, startsWith);
    }
  };
}
async function digestStringAsSHA256(message) {
  const msgUint8 = new TextEncoder().encode(message);
  const hashBuffer = await subtle.digest("SHA-256", msgUint8);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
const defaultCommitURLHandler = (commit) => `${commit.repo_url}/commit/${commit.hash}`;
const defaultReleaseTagURLHandler = (commit) => `${commit.repo_url}/releases/tag/${commit.tag}`;
const defaultReleaseTagsURLHandler = (commit) => commit.tags?.map((tag) => `${commit.repo_url}/releases/tag/${tag}`);
async function returnOrResolvePromise(val) {
  if (!(val instanceof Promise))
    return val;
  return await val;
}
async function rewritePathsByPatterns(commit, path, patterns) {
  if (typeof patterns === "undefined" || patterns === null)
    return path;
  if ("handler" in patterns && typeof patterns.handler === "function") {
    const resolvedPath = await returnOrResolvePromise(patterns.handler(commit, path));
    if (!resolvedPath)
      return path;
    return resolvedPath;
  }
  return path;
}
function rewritePathsByRewritingExtension(from, to) {
  return (_, path) => {
    const ext = extname(path);
    if (ext !== from)
      return path;
    return path.replace(new RegExp(`${from}$`), to);
  };
}
function parseGitLogRefsAsTags(refs) {
  if (!refs)
    return [];
  const refsArray = refs.split(", ").map((ref) => ref.trim());
  const tags = refsArray.filter((ref) => ref.startsWith("tag: "));
  if (!tags)
    return [];
  return tags.map((tag) => tag.replace("tag: ", "").trim());
}
async function getRawCommitLogs(file, maxGitLogCount) {
  const fileDir = dirname(file);
  const fileName = basename(file);
  const format = "%H|%an|%ae|%ad|%s|%d|%b";
  const { stdout } = await execa("git", ["log", `--max-count=${maxGitLogCount ?? -1}`, `--format=${format}[GIT_LOG_COMMIT_END]`, "--follow", "--", fileName], { cwd: fileDir });
  return stdout.replace(/\[GIT_LOG_COMMIT_END\]$/, "").split("[GIT_LOG_COMMIT_END]\n");
}
function getRelativePath(file, srcDir, cwd) {
  cwd = normalizePath(cwd);
  return file.replace(srcDir, "").replace(cwd, "").replace(/^\//, "");
}
async function parseCommits(path, rawLogs, getRepoURL, getCommitURL, getReleaseTagURL, getReleaseTagsURL, optsRewritePathsBy) {
  const commits = await Promise.all(rawLogs.map(async (raw) => {
    const [hash, author_name, author_email, date, message, refs, body] = raw.split("|");
    const commit = {
      path,
      hash,
      date,
      date_timestamp: 0,
      message,
      body,
      author_name,
      author_email,
      author_avatar: ""
    };
    if (typeof optsRewritePathsBy !== "undefined")
      commit.path = await rewritePathsByPatterns(commit, commit.path, optsRewritePathsBy);
    commit.repo_url = await returnOrResolvePromise(getRepoURL(commit)) ?? "https://github.com/example/example";
    commit.hash_url = await returnOrResolvePromise(getCommitURL(commit)) ?? defaultCommitURLHandler(commit);
    const tags = parseGitLogRefsAsTags(refs?.replace(/[\(\)]/g, ""));
    if (tags && tags.length > 0) {
      commit.tags = tags;
      commit.tag = commit.tags?.[0] || void 0;
      commit.release_tag_url = await returnOrResolvePromise(getReleaseTagURL(commit)) ?? defaultReleaseTagURLHandler(commit);
      commit.release_tags_url = await returnOrResolvePromise(getReleaseTagsURL(commit)) ?? defaultReleaseTagsURLHandler(commit);
    }
    commit.date_timestamp = new Date(commit.date).getTime();
    commit.author_avatar = await digestStringAsSHA256(commit.author_email);
    return commit;
  }));
  return commits;
}

const VirtualModuleID = "virtual:nolebase-git-changelog";
const ResolvedVirtualModuleId = `\0${VirtualModuleID}`;
const logModulePrefix = `${cyan(`@nolebase/vitepress-plugin-git-changelog`)}${gray(":")}`;
function GitChangelog(options = {}) {
  if (!options)
    options = {};
  const {
    cwd: cwd$1 = cwd(),
    maxGitLogCount,
    include = ["**/*.md", "!node_modules"],
    repoURL = "https://github.com/example/example",
    getReleaseTagURL = defaultReleaseTagURLHandler,
    getReleaseTagsURL = defaultReleaseTagsURLHandler,
    getCommitURL = defaultCommitURLHandler,
    rewritePathsBy
  } = options;
  let commits = [];
  let srcDir = "";
  return {
    name: "@nolebase/vitepress-plugin-git-changelog",
    config: () => ({
      optimizeDeps: {
        include: [
          // @rive-app/canvas is a CJS/UMD module, so it needs to be included here
          // for Vite to properly bundle it.
          "@nolebase/vitepress-plugin-git-changelog > @nolebase/ui > @rive-app/canvas"
        ],
        exclude: [
          "@nolebase/vitepress-plugin-git-changelog/client"
        ]
      },
      ssr: {
        noExternal: [
          "@nolebase/vitepress-plugin-git-changelog",
          // @nolebase/ui required here as noExternal to avoid the following error:
          // TypeError [ERR_UNKNOWN_FILE_EXTENSION]: Unknown file extension ".vue" for ...
          // Read more here: https://github.com/vuejs/vitepress/issues/2915
          // And here: https://stackblitz.com/edit/vite-gjz9zf?file=docs%2F.vitepress%2Fconfig.ts
          "@nolebase/ui"
        ]
      }
    }),
    configResolved(config) {
      srcDir = config.vitepress.srcDir;
    },
    async buildStart() {
      const startsAt = Date.now();
      const spinner = ora(`${logModulePrefix} Prepare to gather git logs...`).start();
      const getRepoURL = typeof repoURL === "function" ? repoURL : () => repoURL;
      if (commits.length > 0)
        return;
      await execa("git", ["config", "--local", "core.quotepath", "false"]);
      spinner.text = `${logModulePrefix} Gathering git logs...`;
      spinner.color = "yellow";
      const paths = await globby(include, {
        gitignore: true,
        cwd: cwd$1,
        absolute: true
      });
      commits = (await Promise.all(
        paths.map(async (path) => {
          const rawLogs = await getRawCommitLogs(path, maxGitLogCount);
          const relativePath = getRelativePath(path, srcDir, cwd$1);
          return await parseCommits(relativePath, rawLogs, getRepoURL, getCommitURL, getReleaseTagURL, getReleaseTagsURL, rewritePathsBy);
        })
      )).flat();
      const elapsed = Date.now() - startsAt;
      spinner.succeed(`${logModulePrefix} Done. ${gray(`(${elapsed}ms)`)}`);
    },
    resolveId(id) {
      if (id === VirtualModuleID)
        return ResolvedVirtualModuleId;
    },
    load(id) {
      if (id !== ResolvedVirtualModuleId)
        return null;
      const changelog = {
        commits
      };
      return `export default ${JSON.stringify(changelog)}`;
    }
  };
}

const defaultEnLocale = {
  gitChangelogMarkdownSectionTitles: {
    changelog: "Changelog",
    contributors: "Contributors"
  }
};
const defaultZhCNLocale = {
  gitChangelogMarkdownSectionTitles: {
    changelog: "\u9875\u9762\u5386\u53F2",
    contributors: "\u8D21\u732E\u8005"
  }
};
const defaultLocales = {
  "zh-CN": defaultZhCNLocale,
  "zh-Hans": defaultZhCNLocale,
  "zh": defaultZhCNLocale,
  "en-US": defaultEnLocale,
  "en": defaultEnLocale
};

function getValueByPropertyPaths(path, obj) {
  if (!obj)
    return void 0;
  const properties = String(path).split(".");
  let value = obj;
  for (const property of properties) {
    value = value?.[property];
    if (!value)
      return void 0;
  }
  if (typeof value === "string")
    return value;
  return String(value);
}
function createI18nWithLinksPairs(localesLinksPairs, helpers, locales) {
  function t(key) {
    const foundLocales = localesLinksPairs.filter(({ linkPrefix }) => {
      if (!linkPrefix)
        return false;
      const startsWith = helpers.idStartsWith(linkPrefix);
      if (startsWith)
        return true;
      return helpers.idStartsWith(linkPrefix.slice(1));
    });
    if (foundLocales.length === 0)
      return;
    const language = foundLocales[0].language;
    if (!language)
      return;
    const locale = locales?.[language];
    if (!locale)
      return;
    return getValueByPropertyPaths(key, locale);
  }
  return { t };
}
function tChangelogTitle(t, code, id, helpers, options) {
  const defaultValue = defaultEnLocale.gitChangelogMarkdownSectionTitles.changelog;
  if (typeof options?.getChangelogTitle === "function") {
    const changelogTitle = options?.getChangelogTitle(code, id, { helpers });
    if (changelogTitle)
      return changelogTitle;
  }
  return t("gitChangelogMarkdownSectionTitles.changelog") ?? defaultValue;
}
function tContributorsTitle(t, code, id, helpers, options) {
  const defaultValue = defaultEnLocale.gitChangelogMarkdownSectionTitles.contributors;
  if (typeof options?.getContributorsTitle === "function") {
    const contributorsTitle = options?.getContributorsTitle(code, id, { helpers });
    if (contributorsTitle)
      return contributorsTitle;
  }
  return t("gitChangelogMarkdownSectionTitles.contributors") ?? defaultValue;
}
function tTitles(vitepressConfig, options, code, id, helpers) {
  const localesLinksPairs = Object.entries(vitepressConfig.site.locales).map(([_, config]) => ({ language: config.lang, linkPrefix: config.link }));
  let locales = {};
  if (typeof options?.locales !== "undefined" && Object.keys(options.locales).length > 0)
    locales = options.locales;
  else
    locales = defaultLocales;
  const { t } = createI18nWithLinksPairs(localesLinksPairs, helpers, locales);
  return {
    changelogTitle: tChangelogTitle(t, code, id, helpers, options),
    contributorsTitle: tContributorsTitle(t, code, id, helpers, options)
  };
}

function GitChangelogMarkdownSection(options) {
  const {
    excludes = ["index.md"],
    exclude = () => false
  } = options ?? {};
  let root = "";
  let vitepressConfig;
  return {
    name: "@nolebase/vitepress-plugin-git-changelog-markdown-section",
    // May set to 'pre' since end user may use vitepress wrapped vite plugin to
    // specify the plugins, which may cause this plugin to be executed after
    // vitepress or the other markdown processing plugins.
    enforce: "pre",
    configResolved(config) {
      root = config.root ?? "";
      vitepressConfig = config.vitepress;
    },
    transform(code, id) {
      if (!id.endsWith(".md"))
        return null;
      const helpers = createHelpers(root, id);
      if (excludes.includes(relative(root, id)))
        return null;
      if (exclude(id, { helpers }))
        return null;
      const parsedMarkdownContent = GrayMatter(code);
      if ("nolebase" in parsedMarkdownContent.data && "gitChangelog" in parsedMarkdownContent.data.nolebase && !parsedMarkdownContent.data.nolebase.gitChangelog)
        return null;
      if ("gitChangelog" in parsedMarkdownContent.data && !parsedMarkdownContent.data.gitChangelog)
        return null;
      const { contributorsTitle, changelogTitle } = tTitles(vitepressConfig, options, code, id, helpers);
      if (!options?.sections?.disableContributors)
        code = TemplateContributors(code, contributorsTitle ?? defaultEnLocale.gitChangelogMarkdownSectionTitles.contributors);
      if (!options?.sections?.disableChangelog)
        code = TemplateChangelog(code, changelogTitle ?? defaultEnLocale.gitChangelogMarkdownSectionTitles.changelog);
      return code;
    }
  };
}
function TemplateContributors(code, title) {
  return `${code}

## ${title}

<NolebaseGitContributors />
`;
}
function TemplateChangelog(code, title) {
  return `${code}

## ${title}

<NolebaseGitChangelog />
`;
}

export { GitChangelog, GitChangelogMarkdownSection, rewritePathsByRewritingExtension };
//# sourceMappingURL=index.mjs.map
